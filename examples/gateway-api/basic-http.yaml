# Gateway API - Basic HTTP Example (Reference Pattern - RECOMMENDED)
# Deploy dot-ai MCP server with HTTP-only Gateway API access using existing Gateway

# Prerequisites:
# - Kubernetes 1.26+ cluster
# - Gateway API CRDs installed (kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml)
# - GatewayClass available (check with: kubectl get gatewayclass)
# - Gateway controller running (e.g., Istio, Envoy Gateway, Kong)
# - Existing Gateway resource created by platform team

# Configuration:
# - Reference existing Gateway (RECOMMENDED approach)
# - HTTP listener on existing Gateway
# - SSE streaming timeout: 3600s
# - Standard deployment method (Kubernetes resources)

---
# Step 1: Platform team creates shared Gateway (typically in a separate namespace)
# This is done ONCE by the platform/infrastructure team
# Application teams will reference this Gateway in their deployments

apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cluster-gateway
  namespace: gateway-system  # Platform team manages Gateways in dedicated namespace
spec:
  gatewayClassName: istio  # CHANGE THIS: Your GatewayClass name
  listeners:
  - name: http
    protocol: HTTP
    port: 80
    # Allow routes from all namespaces (platform team decision)
    # For production, use ReferenceGrant for more granular control
    allowedRoutes:
      namespaces:
        from: All
  # Optional: Add HTTPS listener if needed
  # - name: https
  #   protocol: HTTPS
  #   port: 443
  #   tls:
  #     mode: Terminate
  #     certificateRefs:
  #     - kind: Secret
  #       name: wildcard-cert
  #   allowedRoutes:
  #     namespaces:
  #       from: All

---
# Step 2: Application team deploys dot-ai referencing the existing Gateway
# Save this to a file (e.g., gateway-http-values.yaml) and use with:
#   helm install dot-ai oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
#     --namespace dot-ai \
#     --create-namespace \
#     -f gateway-http-values.yaml

# Deployment method
deployment:
  method: standard

# Disable traditional Ingress (mutually exclusive with Gateway API)
ingress:
  enabled: false

# Reference existing Gateway (RECOMMENDED)
gateway:
  # Reference the Gateway created by platform team
  name: "cluster-gateway"           # Name of existing Gateway
  namespace: "gateway-system"       # Gateway namespace (if different from app namespace)
  
  # SSE streaming timeouts (applied to HTTPRoute)
  timeouts:
    request: "3600s"
    backendRequest: "3600s"

# Secrets configuration
# IMPORTANT: Either provide values here or create the secret manually before deployment
secrets:
  name: dot-ai-secrets
  
  # Bearer token for HTTP authentication
  # Generate with: openssl rand -base64 32
  auth:
    token: ""  # SET THIS: Your auth token
  
  # AI provider API keys
  anthropic:
    apiKey: ""  # SET THIS: sk-ant-api03-...
  
  openai:
    apiKey: ""  # SET THIS: sk-proj-... (required for embeddings)

# AI provider configuration
ai:
  provider: anthropic

# Qdrant vector database (included automatically)
qdrant:
  enabled: true

---
# Alternative: Manual secret creation (if not providing values in secrets section above)
# This allows you to keep sensitive data out of values.yaml
# Apply with: kubectl apply -f -

apiVersion: v1
kind: Secret
metadata:
  name: dot-ai-secrets
  namespace: dot-ai
type: Opaque
stringData:
  # Generate auth token: openssl rand -base64 32
  auth-token: "REPLACE_WITH_YOUR_AUTH_TOKEN"
  
  # AI provider API keys
  anthropic-api-key: "sk-ant-api03-REPLACE_WITH_YOUR_KEY"
  openai-api-key: "sk-proj-REPLACE_WITH_YOUR_KEY"

---
# Installation Steps:

# 1. Verify prerequisites
echo "Checking Gateway API CRDs..."
kubectl get crd gateways.gateway.networking.k8s.io httproutes.gateway.networking.k8s.io

echo "Checking GatewayClass..."
kubectl get gatewayclass

# 2. Create shared Gateway (ONCE, by platform team)
kubectl create namespace gateway-system
# Apply the Gateway resource above
kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cluster-gateway
  namespace: gateway-system
spec:
  gatewayClassName: istio  # CHANGE THIS
  listeners:
  - name: http
    protocol: HTTP
    port: 80
    allowedRoutes:
      namespaces:
        from: All
EOF

# 3. Wait for Gateway to be ready
kubectl wait --for=condition=Programmed gateway/cluster-gateway -n gateway-system --timeout=300s

# 4. Create application namespace
kubectl create namespace dot-ai

# 5. Create secret (if not using values.yaml approach)
# kubectl apply -f gateway-http-values.yaml  # (only the Secret part)

# 6. Install Helm chart (references existing Gateway)
# Edit gateway-http-values.yaml with your configuration, then:
helm install dot-ai \
  oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
  --namespace dot-ai \
  --create-namespace \
  --set gateway.name=cluster-gateway \
  --set gateway.namespace=gateway-system \
  --set secrets.auth.token="YOUR_TOKEN" \
  --set secrets.anthropic.apiKey="YOUR_KEY" \
  --set secrets.openai.apiKey="YOUR_KEY" \
  --wait

# 7. Verify deployment
kubectl get httproute,service,deployment -n dot-ai

# 8. Get Gateway IP/hostname (from gateway-system namespace)
GATEWAY_IP=$(kubectl get gateway cluster-gateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')
echo "Gateway IP: $GATEWAY_IP"

# 9. Configure DNS
# Point your hostname to the Gateway IP
# Either manually create A record or use external-dns

# 10. Test the MCP server
# Replace with your actual hostname
curl http://dot-ai.example.com/

# Test SSE endpoint
curl -N -H "Accept: text/event-stream" \
  -H "Authorization: Bearer YOUR_AUTH_TOKEN" \
  http://dot-ai.example.com/sse

---
# Cross-Namespace Gateway Access (ReferenceGrant)

# If your Gateway is in a different namespace and uses "from: Same" in allowedRoutes,
# you need a ReferenceGrant to allow cross-namespace access.

# Platform team creates this in the Gateway namespace:
---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: ReferenceGrant
metadata:
  name: allow-dot-ai-routes
  namespace: gateway-system  # Gateway namespace
spec:
  from:
  - group: gateway.networking.k8s.io
    kind: HTTPRoute
    namespace: dot-ai  # Application namespace
  to:
  - group: gateway.networking.k8s.io
    kind: Gateway

---
# Troubleshooting:

# Gateway not found?
kubectl get gateway cluster-gateway -n gateway-system
# Make sure the Gateway exists before deploying the app

# HTTPRoute not routing traffic?
kubectl describe httproute -n dot-ai
# Check parentRef matches Gateway name and namespace

# Cross-namespace access denied?
kubectl get referencegrant -n gateway-system
# Verify ReferenceGrant exists if Gateway is in different namespace

# Connection timeouts?
# Verify timeout configuration in HTTPRoute:
kubectl get httproute -n dot-ai -o yaml | grep -A 5 timeouts

---
# Next Steps:

# - For HTTPS with cert-manager: See https-cert-manager.yaml
# - For development/testing with created Gateway: See external-dns.yaml
# - Full documentation: docs/setup/kubernetes-setup.md

---
# Why Reference Pattern?

# ✅ RECOMMENDED: Reference existing Gateway
# - Platform team manages shared Gateway infrastructure
# - No per-application cloud load balancer costs
# - Centralized Gateway configuration and policies
# - Follows Gateway API best practices
# - Avoids kGateway Envoy deployment naming collisions

# ⚠️  NOT RECOMMENDED: Create Gateway per application
# - Creates separate load balancer per app ($$$ cost)
# - Violates separation of concerns
# - Gateway API anti-pattern
# - Can cause Envoy deployment naming conflicts with kGateway
# - See external-dns.yaml for creation mode (development/testing only)
