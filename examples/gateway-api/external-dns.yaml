# Gateway API - Creation Mode with external-dns (Development/Testing Only)
# Deploy dot-ai MCP server with Gateway creation and automated DNS management

# ⚠️  WARNING: This creates a Gateway per application deployment
# This is NOT RECOMMENDED for production. Use basic-http.yaml (reference pattern) instead.
#
# Use this pattern ONLY for:
# - Development environments
# - Testing Gateway API functionality
# - Single-application clusters
# - Environments where platform team doesn't provide shared Gateway

# Prerequisites:
# - Kubernetes 1.26+ cluster
# - Gateway API CRDs installed
# - GatewayClass available
# - Gateway controller running
# - external-dns installed and configured for your DNS provider

# Configuration:
# - Creates Gateway with -http suffix (to avoid kGateway naming conflicts)
# - HTTP listener on port 80
# - external-dns annotations for automatic DNS record creation
# - SSE streaming timeout: 3600s

---
# Example values.yaml for Helm installation with Gateway creation
# Save this to a file (e.g., gateway-create-values.yaml) and use with:
#   helm install dot-ai oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
#     --namespace dot-ai \
#     --create-namespace \
#     -f gateway-create-values.yaml

# Deployment method
deployment:
  method: standard

# Disable traditional Ingress
ingress:
  enabled: false

# Create Gateway (NOT RECOMMENDED for production)
gateway:
  # Enable Gateway creation (creates <fullname>-http Gateway)
  create: true
  className: "istio"  # CHANGE THIS: Your GatewayClass name
  
  # external-dns annotations for automatic DNS record creation
  annotations:
    external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"  # CHANGE THIS
    # Optional: TTL configuration
    # external-dns.alpha.kubernetes.io/ttl: "300"
  
  listeners:
    # HTTP listener (port 80)
    http:
      enabled: true
      hostname: "dot-ai.example.com"  # CHANGE THIS
    
    # HTTPS listener (disabled for this example)
    https:
      enabled: false
  
  # SSE streaming timeouts
  timeouts:
    request: "3600s"
    backendRequest: "3600s"

# Secrets configuration
secrets:
  name: dot-ai-secrets
  auth:
    token: ""  # SET THIS: openssl rand -base64 32
  anthropic:
    apiKey: ""  # SET THIS: sk-ant-api03-...
  openai:
    apiKey: ""  # SET THIS: sk-proj-...

# AI provider configuration
ai:
  provider: anthropic

# Qdrant vector database
qdrant:
  enabled: true

---
# Alternative: Manual secret creation
apiVersion: v1
kind: Secret
metadata:
  name: dot-ai-secrets
  namespace: dot-ai
type: Opaque
stringData:
  auth-token: "REPLACE_WITH_YOUR_AUTH_TOKEN"
  anthropic-api-key: "sk-ant-api03-REPLACE_WITH_YOUR_KEY"
  openai-api-key: "sk-proj-REPLACE_WITH_YOUR_KEY"

---
# Installation Steps:

# 1. Verify prerequisites
kubectl get crd gateways.gateway.networking.k8s.io httproutes.gateway.networking.k8s.io
kubectl get gatewayclass
kubectl get deploy -n external-dns

# 2. Install dot-ai with Gateway creation
helm install dot-ai \
  oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
  --namespace dot-ai \
  --create-namespace \
  --set gateway.create=true \
  --set gateway.className=istio \
  --set 'gateway.annotations.external-dns\.alpha\.kubernetes\.io/hostname=dot-ai.example.com' \
  --set gateway.listeners.http.hostname=dot-ai.example.com \
  --set secrets.auth.token="YOUR_TOKEN" \
  --set secrets.anthropic.apiKey="YOUR_KEY" \
  --set secrets.openai.apiKey="YOUR_KEY" \
  --wait

# 3. Verify Gateway was created with -http suffix
kubectl get gateway -n dot-ai
# Expected: dot-ai-http (or <release-name>-dot-ai-http)

# 4. Verify HTTPRoute references the created Gateway
kubectl describe httproute -n dot-ai
# Check parentRefs section for Gateway name with -http suffix

# 5. Watch external-dns create DNS record
kubectl logs -n external-dns -l app.kubernetes.io/name=external-dns -f

# 6. Wait for DNS propagation (1-5 minutes)
dig +short dot-ai.example.com
# Should return the Gateway's IP address

# 7. Test the MCP server
curl http://dot-ai.example.com/

# Test SSE endpoint
curl -N -H "Accept: text/event-stream" \
  -H "Authorization: Bearer YOUR_AUTH_TOKEN" \
  http://dot-ai.example.com/sse

---
# Understanding the -http Suffix

# Why does the created Gateway have -http suffix?
# - kGateway (Kong Gateway Operator) creates an Envoy Deployment with the same name as the Gateway
# - Without suffix, Gateway name would match application Deployment name
# - This causes Kubernetes naming conflicts
# - The -http suffix prevents these collisions
#
# Example:
#   Release name: dot-ai
#   Application Deployment: dot-ai
#   Created Gateway: dot-ai-http  (← suffix prevents conflict)
#   HTTPRoute references: dot-ai-http

# The HTTPRoute automatically references the correct Gateway name:
# spec:
#   parentRefs:
#   - name: dot-ai-http  # Automatically resolved
#     kind: Gateway

---
# external-dns Configuration Examples

# AWS Route53:
# gateway:
#   annotations:
#     external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"
#     external-dns.alpha.kubernetes.io/aws-weight: "100"

# Google Cloud DNS:
# gateway:
#   annotations:
#     external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"
#     external-dns.alpha.kubernetes.io/cloudflare-proxied: "false"

# Cloudflare:
# gateway:
#   annotations:
#     external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"
#     external-dns.alpha.kubernetes.io/cloudflare-proxied: "true"  # Enable Cloudflare proxy

# Azure DNS:
# gateway:
#   annotations:
#     external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"

---
# Troubleshooting:

# Gateway not created?
kubectl get gateway -n dot-ai
kubectl describe gateway -n dot-ai
# Check for GatewayClass issues

# DNS record not created?
kubectl logs -n external-dns -l app.kubernetes.io/name=external-dns
# Check external-dns logs for errors

# DNS record points to wrong IP?
kubectl get gateway -n dot-ai -o jsonpath='{.items[0].status.addresses[0].value}'
# Compare with DNS resolution: dig +short dot-ai.example.com

# Gateway name conflict?
kubectl get deploy,gateway -n dot-ai
# Verify Gateway name has -http suffix

---
# Migration to Reference Pattern (RECOMMENDED)

# For production deployments, migrate to reference pattern:

# 1. Platform team creates shared Gateway (ONCE)
kubectl create namespace gateway-system
kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cluster-gateway
  namespace: gateway-system
  annotations:
    external-dns.alpha.kubernetes.io/hostname: "*.example.com"
spec:
  gatewayClassName: istio
  listeners:
  - name: http
    protocol: HTTP
    port: 80
    allowedRoutes:
      namespaces:
        from: All
EOF

# 2. Wait for DNS propagation for the shared Gateway
dig +short example.com

# 3. Update dot-ai deployment to use reference pattern
helm upgrade dot-ai \
  oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
  --namespace dot-ai \
  --set gateway.create=false \
  --set gateway.name=cluster-gateway \
  --set gateway.namespace=gateway-system \
  --set secrets.auth.token="YOUR_TOKEN" \
  --set secrets.anthropic.apiKey="YOUR_KEY" \
  --set secrets.openai.apiKey="YOUR_KEY"

# 4. Verify HTTPRoute now references shared Gateway
kubectl describe httproute -n dot-ai
# parentRefs should now point to cluster-gateway in gateway-system

# 5. Old per-application Gateway is removed
kubectl get gateway -n dot-ai
# Should show no Gateways (HTTPRoute references gateway-system/cluster-gateway)

---
# Cost Comparison

# Creation Mode (this example):
# - 1 Gateway per application = 1 cloud load balancer per application
# - Cost: $18-30/month per application (AWS NLB/ALB, GCP LB, etc.)
# - 10 applications = $180-300/month in load balancer costs

# Reference Mode (RECOMMENDED):
# - 1 shared Gateway = 1 cloud load balancer for all applications
# - Cost: $18-30/month total
# - 10 applications = $18-30/month total (saves $162-270/month!)

---
# Next Steps:

# - For production deployments: See basic-http.yaml (reference pattern)
# - For HTTPS with cert-manager: See https-cert-manager.yaml (reference pattern)
# - Full documentation: docs/setup/kubernetes-setup.md

---
# Summary: When to Use Creation Mode

# ✅ USE creation mode (gateway.create=true) when:
# - Development/testing environments
# - Single-application clusters
# - Platform team doesn't provide shared Gateway
# - Learning Gateway API concepts

# ❌ AVOID creation mode in production:
# - Creates per-application load balancers ($$$)
# - Violates Gateway API separation of concerns
# - Harder to manage centralized policies
# - Can cause naming conflicts with kGateway

# ✅ RECOMMENDED: Reference mode (gateway.name)
# - See basic-http.yaml for reference pattern example
# - Platform team manages shared Gateway
# - Applications reference existing Gateway
# - Follows Gateway API best practices
