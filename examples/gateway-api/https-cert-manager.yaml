# Gateway API - HTTPS with cert-manager Example (Reference Pattern - RECOMMENDED)
# Deploy dot-ai MCP server with HTTPS Gateway API access using existing Gateway

# Prerequisites:
# - Kubernetes 1.26+ cluster
# - Gateway API CRDs installed (kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml)
# - GatewayClass available (check with: kubectl get gatewayclass)
# - Gateway controller running (e.g., Istio, Envoy Gateway, Kong)
# - cert-manager installed (https://cert-manager.io/docs/installation/)
# - ClusterIssuer or Issuer configured (e.g., Let's Encrypt)
# - Existing Gateway resource created by platform team

# Configuration:
# - Reference existing Gateway (RECOMMENDED approach)
# - HTTPS listener on existing Gateway
# - cert-manager managed certificate
# - SSE streaming timeout: 3600s
# - Standard deployment method (Kubernetes resources)

---
# Step 1: Platform team creates shared Gateway with HTTPS (typically in a separate namespace)
# This is done ONCE by the platform/infrastructure team

apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cluster-gateway
  namespace: gateway-system
spec:
  gatewayClassName: istio  # CHANGE THIS: Your GatewayClass name
  listeners:
  # HTTP listener (port 80) - useful for ACME HTTP-01 challenge and HTTP traffic
  - name: http
    protocol: HTTP
    port: 80
    allowedRoutes:
      namespaces:
        from: All
  # HTTPS listener (port 443) with wildcard certificate
  - name: https
    protocol: HTTPS
    port: 443
    tls:
      mode: Terminate
      certificateRefs:
      - kind: Secret
        name: wildcard-tls  # Platform team manages wildcard cert
        namespace: gateway-system
    allowedRoutes:
      namespaces:
        from: All

---
# Platform team's wildcard certificate (optional - managed centrally)
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-tls
  namespace: gateway-system
spec:
  secretName: wildcard-tls
  issuerRef:
    name: letsencrypt-prod  # CHANGE THIS: Your ClusterIssuer name
    kind: ClusterIssuer
  dnsNames:
    - "*.example.com"  # CHANGE THIS: Your wildcard domain
    - "example.com"

---
# Step 2: Application team deploys dot-ai referencing the existing Gateway
# Save this to a file (e.g., gateway-https-values.yaml) and use with:
#   helm install dot-ai oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
#     --namespace dot-ai \
#     --create-namespace \
#     -f gateway-https-values.yaml

# Deployment method
deployment:
  method: standard

# Disable traditional Ingress (mutually exclusive with Gateway API)
ingress:
  enabled: false

# Reference existing Gateway (RECOMMENDED)
gateway:
  # Reference the Gateway created by platform team
  name: "cluster-gateway"
  namespace: "gateway-system"
  
  # SSE streaming timeouts
  timeouts:
    request: "3600s"
    backendRequest: "3600s"

# Secrets configuration
secrets:
  name: dot-ai-secrets
  auth:
    token: ""  # SET THIS: openssl rand -base64 32
  anthropic:
    apiKey: ""  # SET THIS: sk-ant-api03-...
  openai:
    apiKey: ""  # SET THIS: sk-proj-...

# AI provider configuration
ai:
  provider: anthropic

# Qdrant vector database
qdrant:
  enabled: true

---
# Alternative: Manual secret creation
apiVersion: v1
kind: Secret
metadata:
  name: dot-ai-secrets
  namespace: dot-ai
type: Opaque
stringData:
  auth-token: "REPLACE_WITH_YOUR_AUTH_TOKEN"
  anthropic-api-key: "sk-ant-api03-REPLACE_WITH_YOUR_KEY"
  openai-api-key: "sk-proj-REPLACE_WITH_YOUR_KEY"

---
# Installation Steps:

# 1. Verify prerequisites
kubectl get crd gateways.gateway.networking.k8s.io httproutes.gateway.networking.k8s.io
kubectl get crd certificates.cert-manager.io issuers.cert-manager.io clusterissuers.cert-manager.io

# 2. Create shared Gateway with HTTPS (ONCE, by platform team)
kubectl create namespace gateway-system

# Create wildcard certificate
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-tls
  namespace: gateway-system
spec:
  secretName: wildcard-tls
  issuerRef:
    name: letsencrypt-prod  # CHANGE THIS
    kind: ClusterIssuer
  dnsNames:
    - "*.example.com"  # CHANGE THIS
    - "example.com"
EOF

# Wait for certificate
kubectl wait --for=condition=Ready certificate/wildcard-tls -n gateway-system --timeout=300s

# Create Gateway with HTTPS
kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cluster-gateway
  namespace: gateway-system
spec:
  gatewayClassName: istio  # CHANGE THIS
  listeners:
  - name: http
    protocol: HTTP
    port: 80
    allowedRoutes:
      namespaces:
        from: All
  - name: https
    protocol: HTTPS
    port: 443
    tls:
      mode: Terminate
      certificateRefs:
      - kind: Secret
        name: wildcard-tls
    allowedRoutes:
      namespaces:
        from: All
EOF

# 3. Wait for Gateway to be ready
kubectl wait --for=condition=Programmed gateway/cluster-gateway -n gateway-system --timeout=300s

# 4. Install dot-ai (references existing Gateway with HTTPS)
helm install dot-ai \
  oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.166.0 \
  --namespace dot-ai \
  --create-namespace \
  --set gateway.name=cluster-gateway \
  --set gateway.namespace=gateway-system \
  --set secrets.auth.token="YOUR_TOKEN" \
  --set secrets.anthropic.apiKey="YOUR_KEY" \
  --set secrets.openai.apiKey="YOUR_KEY" \
  --wait

# 5. Verify deployment
kubectl get httproute,service,deployment -n dot-ai

# 6. Get Gateway IP/hostname
GATEWAY_IP=$(kubectl get gateway cluster-gateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')
echo "Gateway IP: $GATEWAY_IP"

# 7. Configure DNS
# Point dot-ai.example.com to $GATEWAY_IP

# 8. Test HTTPS endpoint
curl https://dot-ai.example.com/

# Test SSE over HTTPS
curl -N -H "Accept: text/event-stream" \
  -H "Authorization: Bearer YOUR_AUTH_TOKEN" \
  https://dot-ai.example.com/sse

# 9. Verify TLS certificate
openssl s_client -connect dot-ai.example.com:443 -servername dot-ai.example.com < /dev/null 2>/dev/null | openssl x509 -text -noout | grep -A 2 "Subject:"

---
# Per-Application Certificate (Alternative)

# If you prefer a dedicated certificate for dot-ai instead of using the platform's wildcard:

# 1. Create Certificate in dot-ai namespace
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: dot-ai-tls
  namespace: dot-ai
spec:
  secretName: dot-ai-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - dot-ai.example.com

# 2. Wait for certificate
# kubectl wait --for=condition=Ready certificate/dot-ai-tls -n dot-ai --timeout=300s

# 3. Update Gateway to allow cross-namespace certificate reference
# Platform team creates ReferenceGrant:
---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: ReferenceGrant
metadata:
  name: allow-dot-ai-cert
  namespace: dot-ai  # Certificate namespace
spec:
  from:
  - group: gateway.networking.k8s.io
    kind: Gateway
    namespace: gateway-system
  to:
  - group: ""
    kind: Secret
    name: dot-ai-tls

# 4. Update Gateway to use cross-namespace certificate
# This requires platform team to update the Gateway's certificateRefs to include:
#   certificateRefs:
#   - kind: Secret
#     name: dot-ai-tls
#     namespace: dot-ai

---
# Troubleshooting:

# Certificate not ready?
kubectl describe certificate -n gateway-system
kubectl get certificaterequest -n gateway-system
kubectl logs -n cert-manager -l app=cert-manager

# Gateway not using certificate?
kubectl describe gateway cluster-gateway -n gateway-system
# Check certificateRefs in listeners section

# TLS handshake errors?
kubectl get secret wildcard-tls -n gateway-system -o yaml
# Verify secret contains valid certificate

# Cross-namespace reference not working?
kubectl get referencegrant -n gateway-system
kubectl describe referencegrant -n gateway-system

---
# Next Steps:

# - For HTTP-only deployment: See basic-http.yaml
# - For development/testing with created Gateway: See external-dns.yaml
# - Full documentation: docs/setup/kubernetes-setup.md

---
# Why Reference Pattern?

# ✅ RECOMMENDED: Reference existing Gateway with shared certificate
# - Platform team manages Gateway and TLS certificates centrally
# - Wildcard certificates reduce cert-manager load and cost
# - Consistent TLS policies across all applications
# - No per-application Gateway/LoadBalancer costs
# - Follows Gateway API best practices

# ⚠️  NOT RECOMMENDED: Create Gateway per application with per-app cert
# - Each Gateway creates a new cloud load balancer ($$$ cost)
# - Multiple certificates increase cert-manager overhead
# - Harder to manage TLS policies consistently
# - Gateway API anti-pattern
