# Gateway API - HTTPS with cert-manager Example
# Deploy dot-ai MCP server with HTTPS Gateway API access and automated certificate provisioning

# Prerequisites:
# - Kubernetes 1.26+ cluster
# - Gateway API CRDs installed (kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml)
# - GatewayClass available (check with: kubectl get gatewayclass)
# - Gateway controller running (e.g., Istio, Envoy Gateway, Kong)
# - cert-manager installed (https://cert-manager.io/docs/installation/)
# - ClusterIssuer or Issuer configured (e.g., Let's Encrypt)

# Configuration:
# - HTTP listener on port 80 (for ACME HTTP-01 challenge and redirect)
# - HTTPS listener on port 443 with TLS termination
# - cert-manager managed certificate
# - SSE streaming timeout: 3600s
# - Standard deployment method (Kubernetes resources)

---
# Step 1: Create cert-manager Certificate resource
# This will provision a TLS certificate that the Gateway will reference

apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: dot-ai-tls
  namespace: dot-ai
spec:
  secretName: dot-ai-tls  # Secret name that Gateway will reference
  issuerRef:
    name: letsencrypt-prod  # CHANGE THIS: Your ClusterIssuer or Issuer name
    kind: ClusterIssuer
    # Use kind: Issuer if using namespace-scoped Issuer
  dnsNames:
    - dot-ai.example.com  # CHANGE THIS: Your hostname
  # Optional: Add multiple hostnames
  # - www.dot-ai.example.com
  # - api.dot-ai.example.com

---
# Step 2: Helm values.yaml for Gateway API with HTTPS
# Save this to a file (e.g., gateway-https-values.yaml) and use with:
#   helm install dot-ai oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.163.0 \
#     --namespace dot-ai \
#     --create-namespace \
#     -f gateway-https-values.yaml

# Deployment method
deployment:
  method: standard

# Disable traditional Ingress (mutually exclusive with Gateway API)
ingress:
  enabled: false

# Enable Gateway API with HTTPS
gateway:
  enabled: true
  className: "istio"  # CHANGE THIS: Use your GatewayClass name
  
  # Optional: Annotations for integrations
  # annotations:
  #   external-dns.alpha.kubernetes.io/hostname: "dot-ai.example.com"
  
  listeners:
    # HTTP listener (port 80) - useful for ACME HTTP-01 challenge
    http:
      enabled: true
      hostname: "dot-ai.example.com"  # CHANGE THIS: Your hostname
    
    # HTTPS listener (port 443) with TLS termination
    https:
      enabled: true
      hostname: "dot-ai.example.com"  # CHANGE THIS: Your hostname
      secretName: "dot-ai-tls"  # Must match Certificate.spec.secretName above
      
      # Alternative: Use certificateRefs for advanced scenarios
      # certificateRefs:
      #   - kind: Secret
      #     name: dot-ai-tls
      #     # Optional: namespace (for cross-namespace, requires ReferenceGrant)
      #     # namespace: cert-manager
  
  # SSE streaming timeouts
  timeouts:
    request: "3600s"
    backendRequest: "3600s"

# Secrets configuration
secrets:
  name: dot-ai-secrets
  auth:
    token: ""  # SET THIS: openssl rand -base64 32
  anthropic:
    apiKey: ""  # SET THIS: sk-ant-api03-...
  openai:
    apiKey: ""  # SET THIS: sk-proj-...

# AI provider configuration
ai:
  provider: anthropic

# Qdrant vector database
qdrant:
  enabled: true

---
# Alternative: Manual secret creation
# Apply with: kubectl apply -f -

apiVersion: v1
kind: Secret
metadata:
  name: dot-ai-secrets
  namespace: dot-ai
type: Opaque
stringData:
  auth-token: "REPLACE_WITH_YOUR_AUTH_TOKEN"
  anthropic-api-key: "sk-ant-api03-REPLACE_WITH_YOUR_KEY"
  openai-api-key: "sk-proj-REPLACE_WITH_YOUR_KEY"

---
# Installation Steps:

# 1. Verify prerequisites
echo "Checking Gateway API CRDs..."
kubectl get crd gateways.gateway.networking.k8s.io httproutes.gateway.networking.k8s.io

echo "Checking cert-manager CRDs..."
kubectl get crd certificates.cert-manager.io issuers.cert-manager.io clusterissuers.cert-manager.io

echo "Checking GatewayClass..."
kubectl get gatewayclass

echo "Checking ClusterIssuer..."
kubectl get clusterissuer

# 2. Create namespace
kubectl create namespace dot-ai

# 3. Create Certificate resource
# Edit the Certificate above with your hostname and issuer, then apply:
# kubectl apply -f gateway-https-values.yaml  # (only the Certificate part)

# 4. Wait for certificate to be ready
kubectl wait --for=condition=Ready certificate/dot-ai-tls -n dot-ai --timeout=300s

# Verify certificate is ready
kubectl get certificate -n dot-ai
kubectl describe certificate dot-ai-tls -n dot-ai

# 5. Verify TLS secret was created
kubectl get secret dot-ai-tls -n dot-ai

# 6. Create application secrets (if not using values.yaml approach)
# kubectl apply -f gateway-https-values.yaml  # (only the Secret part)

# 7. Install Helm chart
# Edit gateway-https-values.yaml with your configuration, then:
helm install dot-ai \
  oci://ghcr.io/vfarcic/dot-ai/charts/dot-ai:0.163.0 \
  --namespace dot-ai \
  --create-namespace \
  -f gateway-https-values.yaml \
  --wait

# 8. Verify deployment
kubectl get gateway,httproute,service,deployment,certificate -n dot-ai

# 9. Get Gateway IP/hostname
GATEWAY_IP=$(kubectl get gateway dot-ai -n dot-ai -o jsonpath='{.status.addresses[0].value}')
echo "Gateway IP: $GATEWAY_IP"

# 10. Configure DNS
# Point your hostname to the Gateway IP
# Create DNS A record: dot-ai.example.com -> $GATEWAY_IP

# 11. Test HTTPS endpoint
# Replace dot-ai.example.com with your actual hostname
curl https://dot-ai.example.com/

# Test SSE over HTTPS
curl -N -H "Accept: text/event-stream" \
  -H "Authorization: Bearer YOUR_AUTH_TOKEN" \
  https://dot-ai.example.com/sse

# 12. Verify TLS certificate
openssl s_client -connect dot-ai.example.com:443 -servername dot-ai.example.com < /dev/null 2>/dev/null | openssl x509 -text -noout | grep -A 2 "Subject:"

---
# Advanced: Cross-Namespace Certificate Reference

# If your TLS certificate is in a different namespace (e.g., cert-manager namespace),
# you can reference it using certificateRefs with a ReferenceGrant.

# Step 1: Create ReferenceGrant in the certificate namespace
---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: ReferenceGrant
metadata:
  name: allow-dot-ai-cert-access
  namespace: cert-manager  # Namespace where certificate secret exists
spec:
  from:
    - group: gateway.networking.k8s.io
      kind: Gateway
      namespace: dot-ai  # Namespace where Gateway exists
  to:
    - group: ""
      kind: Secret
      name: wildcard-cert  # Optional: restrict to specific secret

# Step 2: Update Gateway configuration to use cross-namespace certificateRef
# In gateway-https-values.yaml:
# gateway:
#   listeners:
#     https:
#       certificateRefs:
#         - kind: Secret
#           name: wildcard-cert
#           namespace: cert-manager

---
# Advanced: HTTP to HTTPS Redirect

# Some Gateway controllers support automatic HTTP to HTTPS redirect.
# Configuration varies by controller:

# Istio example:
# gateway:
#   annotations:
#     networking.istio.io/http-redirect: "true"

# Envoy Gateway example (requires HTTPRoute configuration):
# - Create a second HTTPRoute for HTTP listener with redirect filter
# See Envoy Gateway documentation for redirect configuration

---
# Troubleshooting:

# Certificate not ready?
kubectl describe certificate dot-ai-tls -n dot-ai
kubectl get certificaterequest -n dot-ai
kubectl logs -n cert-manager -l app=cert-manager

# Common issues:
# - DNS not pointing to Gateway IP (required for HTTP-01 challenge)
# - ClusterIssuer not ready or misconfigured
# - Rate limits (Let's Encrypt staging: 30,000/week, prod: 50/week per domain)

# Gateway not using certificate?
kubectl describe gateway dot-ai -n dot-ai
# Look for TLS certificate reference in listeners section

# TLS handshake errors?
# Verify secret exists and contains valid certificate
kubectl get secret dot-ai-tls -n dot-ai -o yaml
# Check cert-manager certificate status
kubectl get certificate dot-ai-tls -n dot-ai -o yaml

# Cross-namespace reference not working?
# Verify ReferenceGrant exists and allows access
kubectl get referencegrant -n cert-manager
kubectl describe referencegrant allow-dot-ai-cert-access -n cert-manager

---
# Certificate Renewal:

# cert-manager automatically renews certificates before expiry.
# Default renewal time: 2/3 of certificate lifetime (e.g., 60 days for 90-day cert)

# Check certificate renewal status:
kubectl get certificate dot-ai-tls -n dot-ai -o yaml | grep -A 10 "status:"

# Force certificate renewal (if needed):
kubectl annotate certificate dot-ai-tls -n dot-ai \
  cert-manager.io/issue-temporary-certificate="true" --overwrite

---
# Example ClusterIssuer (Let's Encrypt Production):

# If you don't have a ClusterIssuer configured, create one:
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@example.com  # CHANGE THIS: Your email for certificate notifications
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        gatewayHTTPRoute:
          parentRefs:
            - kind: Gateway
              name: dot-ai
              namespace: dot-ai

# Apply with: kubectl apply -f -

---
# Next Steps:

# - For external-dns integration: See external-dns.yaml
# - For HTTP-only deployment: See basic-http.yaml
# - For ToolHive deployment: Set deployment.method=toolhive
# - Full documentation: docs/setup/gateway-api-setup.md
